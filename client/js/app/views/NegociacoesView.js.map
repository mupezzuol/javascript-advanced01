{"version":3,"sources":["../../app-es6/views/NegociacoesView.js"],"names":["NegociacoesView","elemento","model","negociacoes","map","DateHelper","dataParaTexto","n","data","quantidade","valor","volume","join","reduce","total","View"],"mappings":";;;;;;;;;;AAAA;IACMA,e;;;AAEF;AACA,6BAAYC,QAAZ,EAAqB;AAAA;;AAAA,iIACXA,QADW,IACD;AACnB;;AAED;AACA;AACA;AACA;AACA;AACA;;;;;iCACSC,K,EAAM;AACX,oaAYcA,MAAMC,WAAN,CAAkBC,GAAlB,CAAsB;AAAA,8FAGVC,WAAWC,aAAX,CAAyBC,EAAEC,IAA3B,CAHU,+CAIVD,EAAEE,UAJQ,+CAKVF,EAAEG,KALQ,+CAMVH,EAAEI,MANQ;AAAA,aAAtB,EASCC,IATD,CASM,EATN,CAZd,kJA0BmBV,MAAMC,WAAN,CAAkBU,MAAlB,CAAyB,UAACC,KAAD,EAAQP,CAAR;AAAA,uBAAcO,QAAQP,EAAEI,MAAxB;AAAA,aAAzB,EAAyD,GAAzD,CA1BnB;AA8BH;;AAGD;;;;;;;;;;;;;;;;;;;;;;;;;;;EA/C0BI,I","file":"NegociacoesView.js","sourcesContent":["//Todos os métodos da classe VIEW são herdados para nossa classe\nclass NegociacoesView extends View{\n\n    //Toda herança em JS qnd vc tem parametro no seu construtor você deve passa-lo para o PAI também\n    constructor(elemento){\n        super(elemento);//Chama construtor da classe Pai (View.js) passando o elemento recebido\n    }\n\n    //Sobrescrevo o método da classe PAI com a implementação diferente\n    //Usando Template String com -> ``\n    //Usamos Arrow Function com MAP para percorrermos nosso model que é nossa lista de negociacoes\n    //para cada elemento da lista nós criamos uma TR, no final retorno uma STRING para nosso template para ele renderizar tudo\n    //porém temos q juntar todos os TR em uma String só, para isso usamos o 'join()' que retorna tudo em uma string gigante unica, assim retorna todas as TR já\n    //Para o TOTAL usamos o IIFE -> Criamos uma função e chamamos ela ao mesmo tempo, auto-chamada, para podermos colocar mais codigos, trab com var etc..\n    template(model){\n        return `\n            <table class=\"table table-hover table-bordered\">\n                <thead>\n                    <tr>\n                        <th>DATA</th>\n                        <th>QUANTIDADE</th>\n                        <th>VALOR</th>\n                        <th>VOLUME</th>\n                    </tr>\n                </thead>\n                \n                <tbody>\n                    ${model.negociacoes.map(n => `\n\n                        <tr>\n                            <td>${DateHelper.dataParaTexto(n.data)}</td>\n                            <td>${n.quantidade}</td>\n                            <td>${n.valor}</td>\n                            <td>${n.volume}</td>\n                        </tr>\n\n                    `).join('')}\n                </tbody>\n                \n                <tfoot>\n                    <td colspan=\"3\"></td>\n                    <td>${ model.negociacoes.reduce((total, n) => total + n.volume, 0.0)}</td>\n                </tfoot>\n            </table>\n        `;\n    }\n\n\n    /*\n    FORMAS DE CALCULAR O TOTAL:\n\n-> Reduce -> Faz o processo de reduzir e retorna somente 1 único valor, usando arrow function é feito o calculo...\n-> Reduce -> Recebe primeiro paramentro 'arrow function' e o segundo o valor que será inicializado no primeiro parametro da function chamada\n\n\n-> Usando REDUCE + ARROW FUNCTION REDUZIDA\n- > (total,n) -> é uma arrow function, 'total' é o valor para ser usado pra soma e o 'n' é a var que representa o item da lista\n${ model.negociacoes.reduce((total, n) => total + n.volume, 0.0)}\n\n\n\n-> Usando IIFE + Arrow Function\n\n    ${\n        (function(){\n            let total = 0.0;\n            model.negociacoes.forEach(n => total += n.volume);\n            return total;\n        )()\n    }\n\n\n\n-> Usando Arrow Function + Reduce\n${model.negociacoes.reduce(function(total, n) {\n               return total + n.volume;\n         }, 0.0)\n        }\n    \n    \n    */\n\n}"]}